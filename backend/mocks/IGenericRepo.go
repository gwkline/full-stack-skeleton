// Code generated by mockery v2.42.0. DO NOT EDIT.

package mocks

import (
	types "github.com/gwkline/full-stack-skeleton/backend/types"
	mock "github.com/stretchr/testify/mock"
	gorm "gorm.io/gorm"
)

// IGenericRepo is an autogenerated mock type for the IGenericRepo type
type IGenericRepo[T interface{}] struct {
	mock.Mock
}

type IGenericRepo_Expecter[T interface{}] struct {
	mock *mock.Mock
}

func (_m *IGenericRepo[T]) EXPECT() *IGenericRepo_Expecter[T] {
	return &IGenericRepo_Expecter[T]{mock: &_m.Mock}
}

// Archive provides a mock function with given fields: entity
func (_m *IGenericRepo[T]) Archive(entity *T) error {
	ret := _m.Called(entity)

	if len(ret) == 0 {
		panic("no return value specified for Archive")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(*T) error); ok {
		r0 = rf(entity)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// IGenericRepo_Archive_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Archive'
type IGenericRepo_Archive_Call[T interface{}] struct {
	*mock.Call
}

// Archive is a helper method to define mock.On call
//   - entity *T
func (_e *IGenericRepo_Expecter[T]) Archive(entity interface{}) *IGenericRepo_Archive_Call[T] {
	return &IGenericRepo_Archive_Call[T]{Call: _e.mock.On("Archive", entity)}
}

func (_c *IGenericRepo_Archive_Call[T]) Run(run func(entity *T)) *IGenericRepo_Archive_Call[T] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*T))
	})
	return _c
}

func (_c *IGenericRepo_Archive_Call[T]) Return(_a0 error) *IGenericRepo_Archive_Call[T] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *IGenericRepo_Archive_Call[T]) RunAndReturn(run func(*T) error) *IGenericRepo_Archive_Call[T] {
	_c.Call.Return(run)
	return _c
}

// Connection provides a mock function with given fields: tx, tableName, filter, sortBy, direction, limit, after
func (_m *IGenericRepo[T]) Connection(tx *gorm.DB, tableName string, filter []types.FilterInput, sortBy string, direction types.AscOrDesc, limit int, after int) ([]*T, *types.PageInfo, error) {
	ret := _m.Called(tx, tableName, filter, sortBy, direction, limit, after)

	if len(ret) == 0 {
		panic("no return value specified for Connection")
	}

	var r0 []*T
	var r1 *types.PageInfo
	var r2 error
	if rf, ok := ret.Get(0).(func(*gorm.DB, string, []types.FilterInput, string, types.AscOrDesc, int, int) ([]*T, *types.PageInfo, error)); ok {
		return rf(tx, tableName, filter, sortBy, direction, limit, after)
	}
	if rf, ok := ret.Get(0).(func(*gorm.DB, string, []types.FilterInput, string, types.AscOrDesc, int, int) []*T); ok {
		r0 = rf(tx, tableName, filter, sortBy, direction, limit, after)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*T)
		}
	}

	if rf, ok := ret.Get(1).(func(*gorm.DB, string, []types.FilterInput, string, types.AscOrDesc, int, int) *types.PageInfo); ok {
		r1 = rf(tx, tableName, filter, sortBy, direction, limit, after)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*types.PageInfo)
		}
	}

	if rf, ok := ret.Get(2).(func(*gorm.DB, string, []types.FilterInput, string, types.AscOrDesc, int, int) error); ok {
		r2 = rf(tx, tableName, filter, sortBy, direction, limit, after)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// IGenericRepo_Connection_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Connection'
type IGenericRepo_Connection_Call[T interface{}] struct {
	*mock.Call
}

// Connection is a helper method to define mock.On call
//   - tx *gorm.DB
//   - tableName string
//   - filter []types.FilterInput
//   - sortBy string
//   - direction types.AscOrDesc
//   - limit int
//   - after int
func (_e *IGenericRepo_Expecter[T]) Connection(tx interface{}, tableName interface{}, filter interface{}, sortBy interface{}, direction interface{}, limit interface{}, after interface{}) *IGenericRepo_Connection_Call[T] {
	return &IGenericRepo_Connection_Call[T]{Call: _e.mock.On("Connection", tx, tableName, filter, sortBy, direction, limit, after)}
}

func (_c *IGenericRepo_Connection_Call[T]) Run(run func(tx *gorm.DB, tableName string, filter []types.FilterInput, sortBy string, direction types.AscOrDesc, limit int, after int)) *IGenericRepo_Connection_Call[T] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*gorm.DB), args[1].(string), args[2].([]types.FilterInput), args[3].(string), args[4].(types.AscOrDesc), args[5].(int), args[6].(int))
	})
	return _c
}

func (_c *IGenericRepo_Connection_Call[T]) Return(_a0 []*T, _a1 *types.PageInfo, _a2 error) *IGenericRepo_Connection_Call[T] {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *IGenericRepo_Connection_Call[T]) RunAndReturn(run func(*gorm.DB, string, []types.FilterInput, string, types.AscOrDesc, int, int) ([]*T, *types.PageInfo, error)) *IGenericRepo_Connection_Call[T] {
	_c.Call.Return(run)
	return _c
}

// Create provides a mock function with given fields: entity
func (_m *IGenericRepo[T]) Create(entity *T) (*T, error) {
	ret := _m.Called(entity)

	if len(ret) == 0 {
		panic("no return value specified for Create")
	}

	var r0 *T
	var r1 error
	if rf, ok := ret.Get(0).(func(*T) (*T, error)); ok {
		return rf(entity)
	}
	if rf, ok := ret.Get(0).(func(*T) *T); ok {
		r0 = rf(entity)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*T)
		}
	}

	if rf, ok := ret.Get(1).(func(*T) error); ok {
		r1 = rf(entity)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IGenericRepo_Create_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Create'
type IGenericRepo_Create_Call[T interface{}] struct {
	*mock.Call
}

// Create is a helper method to define mock.On call
//   - entity *T
func (_e *IGenericRepo_Expecter[T]) Create(entity interface{}) *IGenericRepo_Create_Call[T] {
	return &IGenericRepo_Create_Call[T]{Call: _e.mock.On("Create", entity)}
}

func (_c *IGenericRepo_Create_Call[T]) Run(run func(entity *T)) *IGenericRepo_Create_Call[T] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*T))
	})
	return _c
}

func (_c *IGenericRepo_Create_Call[T]) Return(_a0 *T, _a1 error) *IGenericRepo_Create_Call[T] {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IGenericRepo_Create_Call[T]) RunAndReturn(run func(*T) (*T, error)) *IGenericRepo_Create_Call[T] {
	_c.Call.Return(run)
	return _c
}

// Delete provides a mock function with given fields: entity
func (_m *IGenericRepo[T]) Delete(entity *T) error {
	ret := _m.Called(entity)

	if len(ret) == 0 {
		panic("no return value specified for Delete")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(*T) error); ok {
		r0 = rf(entity)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// IGenericRepo_Delete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Delete'
type IGenericRepo_Delete_Call[T interface{}] struct {
	*mock.Call
}

// Delete is a helper method to define mock.On call
//   - entity *T
func (_e *IGenericRepo_Expecter[T]) Delete(entity interface{}) *IGenericRepo_Delete_Call[T] {
	return &IGenericRepo_Delete_Call[T]{Call: _e.mock.On("Delete", entity)}
}

func (_c *IGenericRepo_Delete_Call[T]) Run(run func(entity *T)) *IGenericRepo_Delete_Call[T] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*T))
	})
	return _c
}

func (_c *IGenericRepo_Delete_Call[T]) Return(_a0 error) *IGenericRepo_Delete_Call[T] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *IGenericRepo_Delete_Call[T]) RunAndReturn(run func(*T) error) *IGenericRepo_Delete_Call[T] {
	_c.Call.Return(run)
	return _c
}

// FindBy provides a mock function with given fields: filters, preloads
func (_m *IGenericRepo[T]) FindBy(filters []types.Filter, preloads ...string) (*T, error) {
	_va := make([]interface{}, len(preloads))
	for _i := range preloads {
		_va[_i] = preloads[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, filters)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FindBy")
	}

	var r0 *T
	var r1 error
	if rf, ok := ret.Get(0).(func([]types.Filter, ...string) (*T, error)); ok {
		return rf(filters, preloads...)
	}
	if rf, ok := ret.Get(0).(func([]types.Filter, ...string) *T); ok {
		r0 = rf(filters, preloads...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*T)
		}
	}

	if rf, ok := ret.Get(1).(func([]types.Filter, ...string) error); ok {
		r1 = rf(filters, preloads...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IGenericRepo_FindBy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindBy'
type IGenericRepo_FindBy_Call[T interface{}] struct {
	*mock.Call
}

// FindBy is a helper method to define mock.On call
//   - filters []types.Filter
//   - preloads ...string
func (_e *IGenericRepo_Expecter[T]) FindBy(filters interface{}, preloads ...interface{}) *IGenericRepo_FindBy_Call[T] {
	return &IGenericRepo_FindBy_Call[T]{Call: _e.mock.On("FindBy",
		append([]interface{}{filters}, preloads...)...)}
}

func (_c *IGenericRepo_FindBy_Call[T]) Run(run func(filters []types.Filter, preloads ...string)) *IGenericRepo_FindBy_Call[T] {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].([]types.Filter), variadicArgs...)
	})
	return _c
}

func (_c *IGenericRepo_FindBy_Call[T]) Return(_a0 *T, _a1 error) *IGenericRepo_FindBy_Call[T] {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IGenericRepo_FindBy_Call[T]) RunAndReturn(run func([]types.Filter, ...string) (*T, error)) *IGenericRepo_FindBy_Call[T] {
	_c.Call.Return(run)
	return _c
}

// FuzzyFindBy provides a mock function with given fields: key, value
func (_m *IGenericRepo[T]) FuzzyFindBy(key string, value interface{}) ([]*T, error) {
	ret := _m.Called(key, value)

	if len(ret) == 0 {
		panic("no return value specified for FuzzyFindBy")
	}

	var r0 []*T
	var r1 error
	if rf, ok := ret.Get(0).(func(string, interface{}) ([]*T, error)); ok {
		return rf(key, value)
	}
	if rf, ok := ret.Get(0).(func(string, interface{}) []*T); ok {
		r0 = rf(key, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*T)
		}
	}

	if rf, ok := ret.Get(1).(func(string, interface{}) error); ok {
		r1 = rf(key, value)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IGenericRepo_FuzzyFindBy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FuzzyFindBy'
type IGenericRepo_FuzzyFindBy_Call[T interface{}] struct {
	*mock.Call
}

// FuzzyFindBy is a helper method to define mock.On call
//   - key string
//   - value interface{}
func (_e *IGenericRepo_Expecter[T]) FuzzyFindBy(key interface{}, value interface{}) *IGenericRepo_FuzzyFindBy_Call[T] {
	return &IGenericRepo_FuzzyFindBy_Call[T]{Call: _e.mock.On("FuzzyFindBy", key, value)}
}

func (_c *IGenericRepo_FuzzyFindBy_Call[T]) Run(run func(key string, value interface{})) *IGenericRepo_FuzzyFindBy_Call[T] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(interface{}))
	})
	return _c
}

func (_c *IGenericRepo_FuzzyFindBy_Call[T]) Return(_a0 []*T, _a1 error) *IGenericRepo_FuzzyFindBy_Call[T] {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IGenericRepo_FuzzyFindBy_Call[T]) RunAndReturn(run func(string, interface{}) ([]*T, error)) *IGenericRepo_FuzzyFindBy_Call[T] {
	_c.Call.Return(run)
	return _c
}

// ListBy provides a mock function with given fields: filters, preloads
func (_m *IGenericRepo[T]) ListBy(filters []types.Filter, preloads ...string) ([]*T, error) {
	_va := make([]interface{}, len(preloads))
	for _i := range preloads {
		_va[_i] = preloads[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, filters)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListBy")
	}

	var r0 []*T
	var r1 error
	if rf, ok := ret.Get(0).(func([]types.Filter, ...string) ([]*T, error)); ok {
		return rf(filters, preloads...)
	}
	if rf, ok := ret.Get(0).(func([]types.Filter, ...string) []*T); ok {
		r0 = rf(filters, preloads...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*T)
		}
	}

	if rf, ok := ret.Get(1).(func([]types.Filter, ...string) error); ok {
		r1 = rf(filters, preloads...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IGenericRepo_ListBy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListBy'
type IGenericRepo_ListBy_Call[T interface{}] struct {
	*mock.Call
}

// ListBy is a helper method to define mock.On call
//   - filters []types.Filter
//   - preloads ...string
func (_e *IGenericRepo_Expecter[T]) ListBy(filters interface{}, preloads ...interface{}) *IGenericRepo_ListBy_Call[T] {
	return &IGenericRepo_ListBy_Call[T]{Call: _e.mock.On("ListBy",
		append([]interface{}{filters}, preloads...)...)}
}

func (_c *IGenericRepo_ListBy_Call[T]) Run(run func(filters []types.Filter, preloads ...string)) *IGenericRepo_ListBy_Call[T] {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].([]types.Filter), variadicArgs...)
	})
	return _c
}

func (_c *IGenericRepo_ListBy_Call[T]) Return(_a0 []*T, _a1 error) *IGenericRepo_ListBy_Call[T] {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IGenericRepo_ListBy_Call[T]) RunAndReturn(run func([]types.Filter, ...string) ([]*T, error)) *IGenericRepo_ListBy_Call[T] {
	_c.Call.Return(run)
	return _c
}

// Update provides a mock function with given fields: entity
func (_m *IGenericRepo[T]) Update(entity *T) (*T, error) {
	ret := _m.Called(entity)

	if len(ret) == 0 {
		panic("no return value specified for Update")
	}

	var r0 *T
	var r1 error
	if rf, ok := ret.Get(0).(func(*T) (*T, error)); ok {
		return rf(entity)
	}
	if rf, ok := ret.Get(0).(func(*T) *T); ok {
		r0 = rf(entity)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*T)
		}
	}

	if rf, ok := ret.Get(1).(func(*T) error); ok {
		r1 = rf(entity)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IGenericRepo_Update_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Update'
type IGenericRepo_Update_Call[T interface{}] struct {
	*mock.Call
}

// Update is a helper method to define mock.On call
//   - entity *T
func (_e *IGenericRepo_Expecter[T]) Update(entity interface{}) *IGenericRepo_Update_Call[T] {
	return &IGenericRepo_Update_Call[T]{Call: _e.mock.On("Update", entity)}
}

func (_c *IGenericRepo_Update_Call[T]) Run(run func(entity *T)) *IGenericRepo_Update_Call[T] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*T))
	})
	return _c
}

func (_c *IGenericRepo_Update_Call[T]) Return(_a0 *T, _a1 error) *IGenericRepo_Update_Call[T] {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IGenericRepo_Update_Call[T]) RunAndReturn(run func(*T) (*T, error)) *IGenericRepo_Update_Call[T] {
	_c.Call.Return(run)
	return _c
}

// NewIGenericRepo creates a new instance of IGenericRepo. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIGenericRepo[T interface{}](t interface {
	mock.TestingT
	Cleanup(func())
}) *IGenericRepo[T] {
	mock := &IGenericRepo[T]{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
